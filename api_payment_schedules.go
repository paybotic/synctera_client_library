/*
Synctera API

<h2>Let's build something great.</h2><p>Welcome to the official reference documentation for Synctera APIs. Our APIs are the best way to automate your company's banking needs and are designed to be easy to understand and implement.</p><p>We're continuously growing this library and what you see here is just the start, but if you need something specific or have a question, <a class='text-blue-600' href='https://synctera.com/contact' target='_blank' rel='noreferrer'>contact us</a>.</p> 

API version: 0.17.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PaymentSchedulesApiService PaymentSchedulesApi service
type PaymentSchedulesApiService service

type PaymentSchedulesApiCreatePaymentScheduleRequest struct {
	ctx context.Context
	ApiService *PaymentSchedulesApiService
	paymentSchedule *PaymentSchedule
}

// payment schedule to create
func (r PaymentSchedulesApiCreatePaymentScheduleRequest) PaymentSchedule(paymentSchedule PaymentSchedule) PaymentSchedulesApiCreatePaymentScheduleRequest {
	r.paymentSchedule = &paymentSchedule
	return r
}

func (r PaymentSchedulesApiCreatePaymentScheduleRequest) Execute() (*PaymentSchedule, *http.Response, error) {
	return r.ApiService.CreatePaymentScheduleExecute(r)
}

/*
CreatePaymentSchedule Create a payment schedule

Create a payment schedule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentSchedulesApiCreatePaymentScheduleRequest
*/
func (a *PaymentSchedulesApiService) CreatePaymentSchedule(ctx context.Context) PaymentSchedulesApiCreatePaymentScheduleRequest {
	return PaymentSchedulesApiCreatePaymentScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentSchedule
func (a *PaymentSchedulesApiService) CreatePaymentScheduleExecute(r PaymentSchedulesApiCreatePaymentScheduleRequest) (*PaymentSchedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentSchedulesApiService.CreatePaymentSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_schedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentSchedule == nil {
		return localVarReturnValue, nil, reportError("paymentSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentSchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentSchedulesApiListPaymentSchedulesRequest struct {
	ctx context.Context
	ApiService *PaymentSchedulesApiService
	limit *int32
	pageToken *string
	id *[]string
	accountId *[]string
	customerId *[]string
}

func (r PaymentSchedulesApiListPaymentSchedulesRequest) Limit(limit int32) PaymentSchedulesApiListPaymentSchedulesRequest {
	r.limit = &limit
	return r
}

func (r PaymentSchedulesApiListPaymentSchedulesRequest) PageToken(pageToken string) PaymentSchedulesApiListPaymentSchedulesRequest {
	r.pageToken = &pageToken
	return r
}

// IDs. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentSchedulesRequest) Id(id []string) PaymentSchedulesApiListPaymentSchedulesRequest {
	r.id = &id
	return r
}

// Originating account IDs. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentSchedulesRequest) AccountId(accountId []string) PaymentSchedulesApiListPaymentSchedulesRequest {
	r.accountId = &accountId
	return r
}

// The IDs of customers who created the payment schedules. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentSchedulesRequest) CustomerId(customerId []string) PaymentSchedulesApiListPaymentSchedulesRequest {
	r.customerId = &customerId
	return r
}

func (r PaymentSchedulesApiListPaymentSchedulesRequest) Execute() (*PaymentScheduleList, *http.Response, error) {
	return r.ApiService.ListPaymentSchedulesExecute(r)
}

/*
ListPaymentSchedules List payment schedules

Get paginated list of payment schedules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentSchedulesApiListPaymentSchedulesRequest
*/
func (a *PaymentSchedulesApiService) ListPaymentSchedules(ctx context.Context) PaymentSchedulesApiListPaymentSchedulesRequest {
	return PaymentSchedulesApiListPaymentSchedulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentScheduleList
func (a *PaymentSchedulesApiService) ListPaymentSchedulesExecute(r PaymentSchedulesApiListPaymentSchedulesRequest) (*PaymentScheduleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentScheduleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentSchedulesApiService.ListPaymentSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_schedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("account_id", parameterToString(*r.accountId, "csv"))
	}
	if r.customerId != nil {
		localVarQueryParams.Add("customer_id", parameterToString(*r.customerId, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentSchedulesApiListPaymentsRequest struct {
	ctx context.Context
	ApiService *PaymentSchedulesApiService
	limit *int32
	pageToken *string
	id *[]string
	scheduleId *[]string
	accountId *[]string
	customerId *[]string
}

func (r PaymentSchedulesApiListPaymentsRequest) Limit(limit int32) PaymentSchedulesApiListPaymentsRequest {
	r.limit = &limit
	return r
}

func (r PaymentSchedulesApiListPaymentsRequest) PageToken(pageToken string) PaymentSchedulesApiListPaymentsRequest {
	r.pageToken = &pageToken
	return r
}

// IDs. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentsRequest) Id(id []string) PaymentSchedulesApiListPaymentsRequest {
	r.id = &id
	return r
}

// Payment schedule IDs. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentsRequest) ScheduleId(scheduleId []string) PaymentSchedulesApiListPaymentsRequest {
	r.scheduleId = &scheduleId
	return r
}

// Originating account IDs. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentsRequest) AccountId(accountId []string) PaymentSchedulesApiListPaymentsRequest {
	r.accountId = &accountId
	return r
}

// The IDs of customers who created the payment schedules. Multiple IDs can be provided as a comma-separated list.
func (r PaymentSchedulesApiListPaymentsRequest) CustomerId(customerId []string) PaymentSchedulesApiListPaymentsRequest {
	r.customerId = &customerId
	return r
}

func (r PaymentSchedulesApiListPaymentsRequest) Execute() (*PaymentList, *http.Response, error) {
	return r.ApiService.ListPaymentsExecute(r)
}

/*
ListPayments List payments

Get paginated list of payments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentSchedulesApiListPaymentsRequest
*/
func (a *PaymentSchedulesApiService) ListPayments(ctx context.Context) PaymentSchedulesApiListPaymentsRequest {
	return PaymentSchedulesApiListPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentList
func (a *PaymentSchedulesApiService) ListPaymentsExecute(r PaymentSchedulesApiListPaymentsRequest) (*PaymentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentSchedulesApiService.ListPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_schedules/payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.scheduleId != nil {
		localVarQueryParams.Add("schedule_id", parameterToString(*r.scheduleId, "csv"))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("account_id", parameterToString(*r.accountId, "csv"))
	}
	if r.customerId != nil {
		localVarQueryParams.Add("customer_id", parameterToString(*r.customerId, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentSchedulesApiPatchPaymentScheduleRequest struct {
	ctx context.Context
	ApiService *PaymentSchedulesApiService
	paymentScheduleId string
	patchPaymentSchedule *PatchPaymentSchedule
}

// payment schedule to update
func (r PaymentSchedulesApiPatchPaymentScheduleRequest) PatchPaymentSchedule(patchPaymentSchedule PatchPaymentSchedule) PaymentSchedulesApiPatchPaymentScheduleRequest {
	r.patchPaymentSchedule = &patchPaymentSchedule
	return r
}

func (r PaymentSchedulesApiPatchPaymentScheduleRequest) Execute() (*PaymentSchedule, *http.Response, error) {
	return r.ApiService.PatchPaymentScheduleExecute(r)
}

/*
PatchPaymentSchedule Update a payment schedule

Update a payment schedule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentScheduleId Payment schedule ID
 @return PaymentSchedulesApiPatchPaymentScheduleRequest
*/
func (a *PaymentSchedulesApiService) PatchPaymentSchedule(ctx context.Context, paymentScheduleId string) PaymentSchedulesApiPatchPaymentScheduleRequest {
	return PaymentSchedulesApiPatchPaymentScheduleRequest{
		ApiService: a,
		ctx: ctx,
		paymentScheduleId: paymentScheduleId,
	}
}

// Execute executes the request
//  @return PaymentSchedule
func (a *PaymentSchedulesApiService) PatchPaymentScheduleExecute(r PaymentSchedulesApiPatchPaymentScheduleRequest) (*PaymentSchedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentSchedulesApiService.PatchPaymentSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payment_schedules/{payment_schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"payment_schedule_id"+"}", url.PathEscape(parameterToString(r.paymentScheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchPaymentSchedule == nil {
		return localVarReturnValue, nil, reportError("patchPaymentSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchPaymentSchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
