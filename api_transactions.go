/*
Synctera API

<h2>Let's build something great.</h2><p>Welcome to the official reference documentation for Synctera APIs. Our APIs are the best way to automate your company's banking needs and are designed to be easy to understand and implement.</p><p>We're continuously growing this library and what you see here is just the start, but if you need something specific or have a question, <a class='text-blue-600' href='https://synctera.com/contact' target='_blank' rel='noreferrer'>contact us</a>.</p>

API version: 0.69.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TransactionsAPIService TransactionsAPI service
type TransactionsAPIService service

type ApiGetPendingTransactionByIDRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	id string
}

func (r ApiGetPendingTransactionByIDRequest) Execute() (*PendingTransaction, *http.Response, error) {
	return r.ApiService.GetPendingTransactionByIDExecute(r)
}

/*
GetPendingTransactionByID Get a pending transaction

Get a pending transaction by its uuid


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Transaction ID
 @return ApiGetPendingTransactionByIDRequest
*/
func (a *TransactionsAPIService) GetPendingTransactionByID(ctx context.Context, id string) ApiGetPendingTransactionByIDRequest {
	return ApiGetPendingTransactionByIDRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PendingTransaction
func (a *TransactionsAPIService) GetPendingTransactionByIDExecute(r ApiGetPendingTransactionByIDRequest) (*PendingTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PendingTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetPendingTransactionByID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/pending/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostedTransactionByIDRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	id string
}

func (r ApiGetPostedTransactionByIDRequest) Execute() (*PostedTransaction, *http.Response, error) {
	return r.ApiService.GetPostedTransactionByIDExecute(r)
}

/*
GetPostedTransactionByID Get a posted transaction

Get a posted transaction by its uuid


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Transaction ID
 @return ApiGetPostedTransactionByIDRequest
*/
func (a *TransactionsAPIService) GetPostedTransactionByID(ctx context.Context, id string) ApiGetPostedTransactionByIDRequest {
	return ApiGetPostedTransactionByIDRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PostedTransaction
func (a *TransactionsAPIService) GetPostedTransactionByIDExecute(r ApiGetPostedTransactionByIDRequest) (*PostedTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetPostedTransactionByID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/posted/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPendingTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	includeChildTransactions *bool
	cardId *string
	type_ *string
	fromDate *string
	toDate *string
	transactionId *string
	status *[]string
	accountId *string
	idempotencyKey *[]string
	accountNo *string
	excludeJitTransactions *bool
	pageToken *string
	referenceId *string
	limit *int32
	subtype *string
}

// Include transactions from sub-accounts when listing transactions for a given account
func (r ApiListPendingTransactionsRequest) IncludeChildTransactions(includeChildTransactions bool) ApiListPendingTransactionsRequest {
	r.includeChildTransactions = &includeChildTransactions
	return r
}

// Card ID
func (r ApiListPendingTransactionsRequest) CardId(cardId string) ApiListPendingTransactionsRequest {
	r.cardId = &cardId
	return r
}

// Only display transactions matching the given type
func (r ApiListPendingTransactionsRequest) Type_(type_ string) ApiListPendingTransactionsRequest {
	r.type_ = &type_
	return r
}

// Only display transactions with a posting date greater than from_date
func (r ApiListPendingTransactionsRequest) FromDate(fromDate string) ApiListPendingTransactionsRequest {
	r.fromDate = &fromDate
	return r
}

// Only display transactions with a posting date less than or equal to to_date
func (r ApiListPendingTransactionsRequest) ToDate(toDate string) ApiListPendingTransactionsRequest {
	r.toDate = &toDate
	return r
}

// Only display holds linked to the provided transaction id
func (r ApiListPendingTransactionsRequest) TransactionId(transactionId string) ApiListPendingTransactionsRequest {
	r.transactionId = &transactionId
	return r
}

// The status of the transaction
func (r ApiListPendingTransactionsRequest) Status(status []string) ApiListPendingTransactionsRequest {
	r.status = &status
	return r
}

// Account ID
func (r ApiListPendingTransactionsRequest) AccountId(accountId string) ApiListPendingTransactionsRequest {
	r.accountId = &accountId
	return r
}

// Transaction Idempotency Key(s). Multiple keys can be provided as a comma-separated list.
func (r ApiListPendingTransactionsRequest) IdempotencyKey(idempotencyKey []string) ApiListPendingTransactionsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Account number
func (r ApiListPendingTransactionsRequest) AccountNo(accountNo string) ApiListPendingTransactionsRequest {
	r.accountNo = &accountNo
	return r
}

// Hide \&quot;JIT funding\&quot; transactions from results
func (r ApiListPendingTransactionsRequest) ExcludeJitTransactions(excludeJitTransactions bool) ApiListPendingTransactionsRequest {
	r.excludeJitTransactions = &excludeJitTransactions
	return r
}

func (r ApiListPendingTransactionsRequest) PageToken(pageToken string) ApiListPendingTransactionsRequest {
	r.pageToken = &pageToken
	return r
}

// Reference ID
func (r ApiListPendingTransactionsRequest) ReferenceId(referenceId string) ApiListPendingTransactionsRequest {
	r.referenceId = &referenceId
	return r
}

func (r ApiListPendingTransactionsRequest) Limit(limit int32) ApiListPendingTransactionsRequest {
	r.limit = &limit
	return r
}

// Only display transactions matching the given subtype
func (r ApiListPendingTransactionsRequest) Subtype(subtype string) ApiListPendingTransactionsRequest {
	r.subtype = &subtype
	return r
}

func (r ApiListPendingTransactionsRequest) Execute() (*PendingTransactions, *http.Response, error) {
	return r.ApiService.ListPendingTransactionsExecute(r)
}

/*
ListPendingTransactions List pending transactions

Get paginated list of pending transactions matching the provided filters


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPendingTransactionsRequest
*/
func (a *TransactionsAPIService) ListPendingTransactions(ctx context.Context) ApiListPendingTransactionsRequest {
	return ApiListPendingTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PendingTransactions
func (a *TransactionsAPIService) ListPendingTransactionsExecute(r ApiListPendingTransactionsRequest) (*PendingTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PendingTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ListPendingTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeChildTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_child_transactions", r.includeChildTransactions, "")
	}
	if r.cardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "card_id", r.cardId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.transactionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_id", r.transactionId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "csv")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "csv")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_no", r.accountNo, "")
	}
	if r.excludeJitTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_jit_transactions", r.excludeJitTransactions, "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
	}
	if r.referenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference_id", r.referenceId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.subtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtype", r.subtype, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPostedTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	includeChildTransactions *bool
	uuid *[]string
	cardId *string
	type_ *string
	fromDate *string
	toDate *string
	accountId *string
	idempotencyKey *[]string
	accountNo *string
	excludeJitTransactions *bool
	pageToken *string
	referenceId *string
	limit *int32
	subtype *string
}

// Include transactions from sub-accounts when listing transactions for a given account
func (r ApiListPostedTransactionsRequest) IncludeChildTransactions(includeChildTransactions bool) ApiListPostedTransactionsRequest {
	r.includeChildTransactions = &includeChildTransactions
	return r
}

// Transaction UUID(s). Multiple UUIDs can be provided as a comma-separated list.
func (r ApiListPostedTransactionsRequest) Uuid(uuid []string) ApiListPostedTransactionsRequest {
	r.uuid = &uuid
	return r
}

// Card ID
func (r ApiListPostedTransactionsRequest) CardId(cardId string) ApiListPostedTransactionsRequest {
	r.cardId = &cardId
	return r
}

// Only display transactions matching the given type
func (r ApiListPostedTransactionsRequest) Type_(type_ string) ApiListPostedTransactionsRequest {
	r.type_ = &type_
	return r
}

// Only display transactions with a posting date greater than from_date
func (r ApiListPostedTransactionsRequest) FromDate(fromDate string) ApiListPostedTransactionsRequest {
	r.fromDate = &fromDate
	return r
}

// Only display transactions with a posting date less than or equal to to_date
func (r ApiListPostedTransactionsRequest) ToDate(toDate string) ApiListPostedTransactionsRequest {
	r.toDate = &toDate
	return r
}

// Account ID
func (r ApiListPostedTransactionsRequest) AccountId(accountId string) ApiListPostedTransactionsRequest {
	r.accountId = &accountId
	return r
}

// Transaction Idempotency Key(s). Multiple keys can be provided as a comma-separated list.
func (r ApiListPostedTransactionsRequest) IdempotencyKey(idempotencyKey []string) ApiListPostedTransactionsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Account number
func (r ApiListPostedTransactionsRequest) AccountNo(accountNo string) ApiListPostedTransactionsRequest {
	r.accountNo = &accountNo
	return r
}

// Hide \&quot;JIT funding\&quot; transactions from results
func (r ApiListPostedTransactionsRequest) ExcludeJitTransactions(excludeJitTransactions bool) ApiListPostedTransactionsRequest {
	r.excludeJitTransactions = &excludeJitTransactions
	return r
}

func (r ApiListPostedTransactionsRequest) PageToken(pageToken string) ApiListPostedTransactionsRequest {
	r.pageToken = &pageToken
	return r
}

// Reference ID
func (r ApiListPostedTransactionsRequest) ReferenceId(referenceId string) ApiListPostedTransactionsRequest {
	r.referenceId = &referenceId
	return r
}

func (r ApiListPostedTransactionsRequest) Limit(limit int32) ApiListPostedTransactionsRequest {
	r.limit = &limit
	return r
}

// Only display transactions matching the given subtype
func (r ApiListPostedTransactionsRequest) Subtype(subtype string) ApiListPostedTransactionsRequest {
	r.subtype = &subtype
	return r
}

func (r ApiListPostedTransactionsRequest) Execute() (*PostedTransactions, *http.Response, error) {
	return r.ApiService.ListPostedTransactionsExecute(r)
}

/*
ListPostedTransactions List posted transactions

Get paginated list of posted transactions matching the provided filters


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPostedTransactionsRequest
*/
func (a *TransactionsAPIService) ListPostedTransactions(ctx context.Context) ApiListPostedTransactionsRequest {
	return ApiListPostedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostedTransactions
func (a *TransactionsAPIService) ListPostedTransactionsExecute(r ApiListPostedTransactionsRequest) (*PostedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ListPostedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/posted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeChildTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_child_transactions", r.includeChildTransactions, "")
	}
	if r.uuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "csv")
	}
	if r.cardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "card_id", r.cardId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "csv")
	}
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_no", r.accountNo, "")
	}
	if r.excludeJitTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_jit_transactions", r.excludeJitTransactions, "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
	}
	if r.referenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference_id", r.referenceId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.subtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtype", r.subtype, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
