/*
Synctera API

<h2>Let's build something great.</h2><p>Welcome to the official reference documentation for Synctera APIs. Our APIs are the best way to automate your company's banking needs and are designed to be easy to understand and implement.</p><p>We're continuously growing this library and what you see here is just the start, but if you need something specific or have a question, <a class='text-blue-600' href='https://synctera.com/contact' target='_blank' rel='noreferrer'>contact us</a>.</p>

API version: 0.69.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EFTCanadaAlphaAPIService EFTCanadaAlphaAPI service
type EFTCanadaAlphaAPIService service

type ApiCreateEFTCATransferRequest struct {
	ctx context.Context
	ApiService *EFTCanadaAlphaAPIService
	idempotencyKey *string
	eftCaPost *EftCaPost
}

// An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
func (r ApiCreateEFTCATransferRequest) IdempotencyKey(idempotencyKey string) ApiCreateEFTCATransferRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// The EFT Canada transfer to be created.
func (r ApiCreateEFTCATransferRequest) EftCaPost(eftCaPost EftCaPost) ApiCreateEFTCATransferRequest {
	r.eftCaPost = &eftCaPost
	return r
}

func (r ApiCreateEFTCATransferRequest) Execute() (*EftCaResponse, *http.Response, error) {
	return r.ApiService.CreateEFTCATransferExecute(r)
}

/*
CreateEFTCATransfer Create EFT Canada Transfer

Create a new EFT Canada transfer
> ðŸš§ Alpha > This is an Alpha spec-only endpoint. Feedback from the community is welcome. We may make breaking changes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEFTCATransferRequest
*/
func (a *EFTCanadaAlphaAPIService) CreateEFTCATransfer(ctx context.Context) ApiCreateEFTCATransferRequest {
	return ApiCreateEFTCATransferRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EftCaResponse
func (a *EFTCanadaAlphaAPIService) CreateEFTCATransferExecute(r ApiCreateEFTCATransferRequest) (*EftCaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EftCaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EFTCanadaAlphaAPIService.CreateEFTCATransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eft_ca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.eftCaPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEFTCATransferRequest struct {
	ctx context.Context
	ApiService *EFTCanadaAlphaAPIService
	id string
}

func (r ApiGetEFTCATransferRequest) Execute() (*EftCaResponse, *http.Response, error) {
	return r.ApiService.GetEFTCATransferExecute(r)
}

/*
GetEFTCATransfer Get EFT Canada Transfer

Get a specific EFT Canada transfer
> ðŸš§ Alpha > This is an Alpha spec-only endpoint. Feedback from the community is welcome. We may make breaking changes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id EFT Canada Transfer ID
 @return ApiGetEFTCATransferRequest
*/
func (a *EFTCanadaAlphaAPIService) GetEFTCATransfer(ctx context.Context, id string) ApiGetEFTCATransferRequest {
	return ApiGetEFTCATransferRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EftCaResponse
func (a *EFTCanadaAlphaAPIService) GetEFTCATransferExecute(r ApiGetEFTCATransferRequest) (*EftCaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EftCaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EFTCanadaAlphaAPIService.GetEFTCATransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eft_ca/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEFTCATransfersRequest struct {
	ctx context.Context
	ApiService *EFTCanadaAlphaAPIService
	id *string
	isSameDay *bool
	networkStatus *string
	subtype *string
	toPostingDate *string
	minAmount *int32
	originatingAccountOwnerName *string
	fromEffectiveDate *string
	originatingAccountNumber *string
	originatingAccountId *string
	currency *string
	toEffectiveDate *string
	dcSign *string
	postingDate *string
	effectiveDate *string
	customerId *string
	amount *string
	destinationAccountOwnerName *string
	referenceId *string
	fromPostingDate *string
	status *string
	partnerId *string
	destinationAccountId *string
	destinationAccountNumber *string
	bankId *string
	maxAmount *int32
}

// EFT Canada Transfer ID
func (r ApiGetEFTCATransfersRequest) Id(id string) ApiGetEFTCATransfersRequest {
	r.id = &id
	return r
}

// Is same day transfer
func (r ApiGetEFTCATransfersRequest) IsSameDay(isSameDay bool) ApiGetEFTCATransfersRequest {
	r.isSameDay = &isSameDay
	return r
}

// Network status of the transfer
func (r ApiGetEFTCATransfersRequest) NetworkStatus(networkStatus string) ApiGetEFTCATransfersRequest {
	r.networkStatus = &networkStatus
	return r
}

// Subtype of the transfer
func (r ApiGetEFTCATransfersRequest) Subtype(subtype string) ApiGetEFTCATransfersRequest {
	r.subtype = &subtype
	return r
}

// To posting date of the transfer
func (r ApiGetEFTCATransfersRequest) ToPostingDate(toPostingDate string) ApiGetEFTCATransfersRequest {
	r.toPostingDate = &toPostingDate
	return r
}

// Minimum amount of the transfer
func (r ApiGetEFTCATransfersRequest) MinAmount(minAmount int32) ApiGetEFTCATransfersRequest {
	r.minAmount = &minAmount
	return r
}

// Originating account owner name
func (r ApiGetEFTCATransfersRequest) OriginatingAccountOwnerName(originatingAccountOwnerName string) ApiGetEFTCATransfersRequest {
	r.originatingAccountOwnerName = &originatingAccountOwnerName
	return r
}

// From effective date of the transfer
func (r ApiGetEFTCATransfersRequest) FromEffectiveDate(fromEffectiveDate string) ApiGetEFTCATransfersRequest {
	r.fromEffectiveDate = &fromEffectiveDate
	return r
}

// Originating account number
func (r ApiGetEFTCATransfersRequest) OriginatingAccountNumber(originatingAccountNumber string) ApiGetEFTCATransfersRequest {
	r.originatingAccountNumber = &originatingAccountNumber
	return r
}

// Originating account ID
func (r ApiGetEFTCATransfersRequest) OriginatingAccountId(originatingAccountId string) ApiGetEFTCATransfersRequest {
	r.originatingAccountId = &originatingAccountId
	return r
}

// Currency of the transfer
func (r ApiGetEFTCATransfersRequest) Currency(currency string) ApiGetEFTCATransfersRequest {
	r.currency = &currency
	return r
}

// To effective date of the transfer
func (r ApiGetEFTCATransfersRequest) ToEffectiveDate(toEffectiveDate string) ApiGetEFTCATransfersRequest {
	r.toEffectiveDate = &toEffectiveDate
	return r
}

// DC sign of the transfer
func (r ApiGetEFTCATransfersRequest) DcSign(dcSign string) ApiGetEFTCATransfersRequest {
	r.dcSign = &dcSign
	return r
}

// Posting date of the transfer
func (r ApiGetEFTCATransfersRequest) PostingDate(postingDate string) ApiGetEFTCATransfersRequest {
	r.postingDate = &postingDate
	return r
}

// Effective date of the transfer
func (r ApiGetEFTCATransfersRequest) EffectiveDate(effectiveDate string) ApiGetEFTCATransfersRequest {
	r.effectiveDate = &effectiveDate
	return r
}

// Customer ID of the transfer
func (r ApiGetEFTCATransfersRequest) CustomerId(customerId string) ApiGetEFTCATransfersRequest {
	r.customerId = &customerId
	return r
}

// Amount of the transfer
func (r ApiGetEFTCATransfersRequest) Amount(amount string) ApiGetEFTCATransfersRequest {
	r.amount = &amount
	return r
}

// Destination account owner name
func (r ApiGetEFTCATransfersRequest) DestinationAccountOwnerName(destinationAccountOwnerName string) ApiGetEFTCATransfersRequest {
	r.destinationAccountOwnerName = &destinationAccountOwnerName
	return r
}

// Reference ID of the transfer
func (r ApiGetEFTCATransfersRequest) ReferenceId(referenceId string) ApiGetEFTCATransfersRequest {
	r.referenceId = &referenceId
	return r
}

// From posting date of the transfer
func (r ApiGetEFTCATransfersRequest) FromPostingDate(fromPostingDate string) ApiGetEFTCATransfersRequest {
	r.fromPostingDate = &fromPostingDate
	return r
}

// Status of the transfer
func (r ApiGetEFTCATransfersRequest) Status(status string) ApiGetEFTCATransfersRequest {
	r.status = &status
	return r
}

// Partner ID of the transfer
func (r ApiGetEFTCATransfersRequest) PartnerId(partnerId string) ApiGetEFTCATransfersRequest {
	r.partnerId = &partnerId
	return r
}

// Destination account ID
func (r ApiGetEFTCATransfersRequest) DestinationAccountId(destinationAccountId string) ApiGetEFTCATransfersRequest {
	r.destinationAccountId = &destinationAccountId
	return r
}

// Destination account number
func (r ApiGetEFTCATransfersRequest) DestinationAccountNumber(destinationAccountNumber string) ApiGetEFTCATransfersRequest {
	r.destinationAccountNumber = &destinationAccountNumber
	return r
}

// Bank ID of the transfer
func (r ApiGetEFTCATransfersRequest) BankId(bankId string) ApiGetEFTCATransfersRequest {
	r.bankId = &bankId
	return r
}

// Maximum amount of the transfer
func (r ApiGetEFTCATransfersRequest) MaxAmount(maxAmount int32) ApiGetEFTCATransfersRequest {
	r.maxAmount = &maxAmount
	return r
}

func (r ApiGetEFTCATransfersRequest) Execute() (*EftCaList, *http.Response, error) {
	return r.ApiService.GetEFTCATransfersExecute(r)
}

/*
GetEFTCATransfers Get EFT Canada Transfers

Get all EFT Canada transfers
> ðŸš§ Alpha > This is an Alpha spec-only endpoint. Feedback from the community is welcome. We may make breaking changes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEFTCATransfersRequest
*/
func (a *EFTCanadaAlphaAPIService) GetEFTCATransfers(ctx context.Context) ApiGetEFTCATransfersRequest {
	return ApiGetEFTCATransfersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EftCaList
func (a *EFTCanadaAlphaAPIService) GetEFTCATransfersExecute(r ApiGetEFTCATransfersRequest) (*EftCaList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EftCaList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EFTCanadaAlphaAPIService.GetEFTCATransfers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eft_ca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.isSameDay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_same_day", r.isSameDay, "")
	}
	if r.networkStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network_status", r.networkStatus, "")
	}
	if r.subtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtype", r.subtype, "")
	}
	if r.toPostingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_posting_date", r.toPostingDate, "")
	}
	if r.minAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_amount", r.minAmount, "")
	}
	if r.originatingAccountOwnerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originating_account_owner_name", r.originatingAccountOwnerName, "")
	}
	if r.fromEffectiveDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_effective_date", r.fromEffectiveDate, "")
	}
	if r.originatingAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originating_account_number", r.originatingAccountNumber, "")
	}
	if r.originatingAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originating_account_id", r.originatingAccountId, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.toEffectiveDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_effective_date", r.toEffectiveDate, "")
	}
	if r.dcSign != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dc_sign", r.dcSign, "")
	}
	if r.postingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "posting_date", r.postingDate, "")
	}
	if r.effectiveDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "effective_date", r.effectiveDate, "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.destinationAccountOwnerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination_account_owner_name", r.destinationAccountOwnerName, "")
	}
	if r.referenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference_id", r.referenceId, "")
	}
	if r.fromPostingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_posting_date", r.fromPostingDate, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.partnerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partner_id", r.partnerId, "")
	}
	if r.destinationAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination_account_id", r.destinationAccountId, "")
	}
	if r.destinationAccountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination_account_number", r.destinationAccountNumber, "")
	}
	if r.bankId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bank_id", r.bankId, "")
	}
	if r.maxAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_amount", r.maxAmount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEFTCATransferRequest struct {
	ctx context.Context
	ApiService *EFTCanadaAlphaAPIService
	id string
	idempotencyKey *string
	eftCaPatch *EftCaPatch
}

// An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
func (r ApiPatchEFTCATransferRequest) IdempotencyKey(idempotencyKey string) ApiPatchEFTCATransferRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Properties of the EFT Canada transfer to update.
func (r ApiPatchEFTCATransferRequest) EftCaPatch(eftCaPatch EftCaPatch) ApiPatchEFTCATransferRequest {
	r.eftCaPatch = &eftCaPatch
	return r
}

func (r ApiPatchEFTCATransferRequest) Execute() (*EftCaResponse, *http.Response, error) {
	return r.ApiService.PatchEFTCATransferExecute(r)
}

/*
PatchEFTCATransfer Update a EFT Canada Transfer

To cancel a transfer, update the status to 'CANCELLED'. Only 'PENDING` transfers can be cancelled.
> ðŸš§ Alpha > This is an Alpha spec-only endpoint. Feedback from the community is welcome. We may make breaking changes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id EFT Canada Transfer ID
 @return ApiPatchEFTCATransferRequest
*/
func (a *EFTCanadaAlphaAPIService) PatchEFTCATransfer(ctx context.Context, id string) ApiPatchEFTCATransferRequest {
	return ApiPatchEFTCATransferRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EftCaResponse
func (a *EFTCanadaAlphaAPIService) PatchEFTCATransferExecute(r ApiPatchEFTCATransferRequest) (*EftCaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EftCaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EFTCanadaAlphaAPIService.PatchEFTCATransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eft_ca/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.eftCaPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnEFTCATransferRequest struct {
	ctx context.Context
	ApiService *EFTCanadaAlphaAPIService
	id string
	idempotencyKey *string
}

// An idempotency key is an arbitrary unique value generated by client to detect subsequent retries of the same request. It is recommended that a UUID or a similar random identifier be used as an idempotency key. A different key must be used for each request, unless it is a retry.
func (r ApiReturnEFTCATransferRequest) IdempotencyKey(idempotencyKey string) ApiReturnEFTCATransferRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiReturnEFTCATransferRequest) Execute() (*EftCaResponse, *http.Response, error) {
	return r.ApiService.ReturnEFTCATransferExecute(r)
}

/*
ReturnEFTCATransfer Return an EFT Canada Transfer

Trigger a return upon an existing transfer.
> ðŸš§ Alpha > This is an Alpha spec-only endpoint. Feedback from the community is welcome. We may make breaking changes.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id EFT Canada Transfer ID
 @return ApiReturnEFTCATransferRequest
*/
func (a *EFTCanadaAlphaAPIService) ReturnEFTCATransfer(ctx context.Context, id string) ApiReturnEFTCATransferRequest {
	return ApiReturnEFTCATransferRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EftCaResponse
func (a *EFTCanadaAlphaAPIService) ReturnEFTCATransferExecute(r ApiReturnEFTCATransferRequest) (*EftCaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EftCaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EFTCanadaAlphaAPIService.ReturnEFTCATransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eft_ca/{id}/return"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
