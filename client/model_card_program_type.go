/*
Synctera API

This is the official reference documentation for Synctera APIs. If you need something specific or have a question, <a class='text-blue-600' href='https://synctera.com/contact-us' target='_blank' rel='noreferrer'>contact us</a>.</p>

API version: 0.150.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package synctera_client

import (
	"encoding/json"
	"fmt"
)

// CardProgramType The type of the card program and BIN. This includes CREDIT and PREPAID as a way to use these types of products prior to v1 being available. Until v1 card program and BIN APIs are available you can create CREDIT and PREPAID BINs and card programs using the v1 API. Note that dealing with CREDIT and PREPAID cards requires the v1 API.
type CardProgramType string

// List of card_program_type
const (
	CARDPROGRAMTYPE_CREDIT  CardProgramType = "CREDIT"
	CARDPROGRAMTYPE_DEBIT   CardProgramType = "DEBIT"
	CARDPROGRAMTYPE_PREPAID CardProgramType = "PREPAID"
)

// All allowed values of CardProgramType enum
var AllowedCardProgramTypeEnumValues = []CardProgramType{
	"CREDIT",
	"DEBIT",
	"PREPAID",
}

func (v *CardProgramType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := CardProgramType(value)
	for _, existing := range AllowedCardProgramTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid CardProgramType", value)
}

// NewCardProgramTypeFromValue returns a pointer to a valid CardProgramType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewCardProgramTypeFromValue(v string) (*CardProgramType, error) {
	ev := CardProgramType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for CardProgramType: valid values are %v", v, AllowedCardProgramTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v CardProgramType) IsValid() bool {
	for _, existing := range AllowedCardProgramTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to card_program_type value
func (v CardProgramType) Ptr() *CardProgramType {
	return &v
}

type NullableCardProgramType struct {
	value *CardProgramType
	isSet bool
}

func (v NullableCardProgramType) Get() *CardProgramType {
	return v.value
}

func (v *NullableCardProgramType) Set(val *CardProgramType) {
	v.value = val
	v.isSet = true
}

func (v NullableCardProgramType) IsSet() bool {
	return v.isSet
}

func (v *NullableCardProgramType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCardProgramType(val *CardProgramType) *NullableCardProgramType {
	return &NullableCardProgramType{value: val, isSet: true}
}

func (v NullableCardProgramType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCardProgramType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
